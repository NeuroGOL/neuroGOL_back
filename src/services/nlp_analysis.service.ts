import { pool } from '../config/db';
import { NLPAnalysis } from '../models/nlp_analysis.model';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { ERROR_MESSAGES } from '../utils/errorMessages';
import { log } from 'console';
import { NextFunction, Request, Response } from 'express';
import { pipeline } from '@xenova/transformers';

const genAI = new GoogleGenerativeAI(process.env.GENERIC_API_KEY!);
let emotionClassifier: any = null;

export class NLPAnalysisService {
  static async getAllNLPAnalysis(): Promise<NLPAnalysis[]> {
    try {
      const result = await pool.query('SELECT * FROM nlp_analysis ORDER BY created_at DESC');
      return result.rows;
    } catch (error) {
      console.error('‚ùå Error obteniendo an√°lisis NLP:', error);
      throw new Error(ERROR_MESSAGES.GET_NLP_ERROR);
    }
  }

  static async getNLPAnalysisById(id: number): Promise<NLPAnalysis | null> {
    try {
      if (!id || isNaN(id)) throw new Error(ERROR_MESSAGES.INVALID_ID);

      const result = await pool.query('SELECT * FROM nlp_analysis WHERE id = $1', [id]);
      return result.rows[0] || null;
    } catch (error) {
      console.error('‚ùå Error obteniendo an√°lisis NLP por ID:', error);
      throw new Error(ERROR_MESSAGES.NLP_NOT_FOUND);
    }
  }

  static async createNLPAnalysis(declaration_id: number): Promise<NLPAnalysis> {
    try {
      console.log("üì• ID recibido en createNLPAnalysis:", declaration_id);

      if (!declaration_id || isNaN(declaration_id)) {
        console.error("‚ùå Error: ID de declaraci√≥n inv√°lido:", declaration_id);
        throw new Error(ERROR_MESSAGES.INVALID_ID);
      }

      // üîπ Obtener la declaraci√≥n
      const declarationResult = await pool.query('SELECT texto FROM declarations WHERE id = $1', [declaration_id]);

      if (declarationResult.rowCount === 0) {
        console.error("‚ùå Declaraci√≥n no encontrada:", declaration_id);
        throw new Error(ERROR_MESSAGES.DECLARATION_NOT_FOUND);
      }

      const texto = declarationResult.rows[0].texto;

      if (!texto || texto.trim() === '') {
        console.error("‚ùå La declaraci√≥n est√° vac√≠a.");
        throw new Error(ERROR_MESSAGES.DECLARATION_TEXT_NOT_FOUND);
      }

      console.log("üìú Texto de la declaraci√≥n:", texto);

      // üîπ An√°lisis con IA
      const emocion_ingles = await NLPAnalysisService.analyzeEmotionWithHuggingFace(texto);
      const emocion_detectada = await NLPAnalysisService.translateEmotionToSpanishWithGemini(emocion_ingles);
      const nlpResults = await NLPAnalysisService.generateDetailedAnalysisWithGemini(texto, emocion_detectada);

      // üîπ Insertar resultado en `nlp_analysis`
      const result = await pool.query(
        `INSERT INTO nlp_analysis (declaration_id, emocion_detectada, tendencia_emocional, impacto_en_rendimiento, 
          impacto_en_equipo, estado_actual_emocional, rendimiento_predicho, resumen_general, acciones_recomendadas) 
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING *`,
        [
          declaration_id, emocion_detectada, nlpResults.tendencia_emocional, nlpResults.impacto_en_rendimiento,
          nlpResults.impacto_en_equipo, nlpResults.estado_actual_emocional, nlpResults.rendimiento_predicho,
          nlpResults.resumen_general, nlpResults.acciones_recomendadas
        ]
      );

      console.log("‚úÖ An√°lisis NLP creado:", result.rows[0]);
      return result.rows[0];

    } catch (error) {
      console.error("‚ùå Error en createNLPAnalysis:", error);
      throw new Error(ERROR_MESSAGES.CREATE_NLP_ERROR);
    }
  }

  static async deleteNLPAnalysis(id: number): Promise<boolean> {
    try {
      if (!id || isNaN(id)) throw new Error(ERROR_MESSAGES.INVALID_ID);

      const nlpExists = await pool.query('SELECT id FROM nlp_analysis WHERE id = $1', [id]);
      if (nlpExists.rowCount === 0) {
        throw new Error(ERROR_MESSAGES.NLP_NOT_FOUND);
      }

      const result = await pool.query('DELETE FROM nlp_analysis WHERE id = $1 RETURNING id', [id]);
      return result.rowCount !== null && result.rowCount > 0;
    } catch (error) {
      console.error('‚ùå Error eliminando an√°lisis NLP:', error);
      throw new Error(ERROR_MESSAGES.DELETE_NLP_ERROR);
    }
  }

  // üîπ M√©todo para analizar emociones con Gemini
  static async analyzeEmotionWithHuggingFace(text: string): Promise<string> {
    try {
      // üîπ Traducir usando Gemini
      const translatedText = await NLPAnalysisService.translateToEnglishWithGemini(text);

      // üîπ Cargar modelo si no se ha cargado a√∫n
      if (!emotionClassifier) {
        emotionClassifier = await pipeline(
          'text-classification',
          'Xenova/j-hartmann/emotion-english-distilroberta-base',
          { quantized: true }
        );
      }

      // üîπ Analizar emoci√≥n con el texto traducido
      const result = await emotionClassifier(translatedText, { topk: 1 });
      const predictedEmotion = result[0].label;

      console.log("üéØ Emoci√≥n detectada:", predictedEmotion);
      return predictedEmotion;
    } catch (error) {
      console.error("‚ùå Error en an√°lisis de emoci√≥n:", error);
      throw new Error("Error al analizar emoci√≥n con Hugging Face.");
    }
  }

  // üîπ M√©todo para generar an√°lisis detallado con Gemini
  static async generateDetailedAnalysisWithGemini(text: string, emocion_detectada: string) {
    try {
      const prompt = `Analiza la siguiente declaraci√≥n: "${text}". La emoci√≥n detectada es "${emocion_detectada}".  

      Devuelve un JSON con:
      {
        "tendencia_emocional": "Describe c√≥mo han cambiado las emociones a lo largo del tiempo.",
        "impacto_en_rendimiento": "Positivo / Negativo / Neutro",
        "impacto_en_equipo": "Positivo / Negativo / Neutro",
        "estado_actual_emocional": "Estable / Inestable / En riesgo",
        "rendimiento_predicho": "Alto / Medio / Bajo",
        "resumen_general": "Explicaci√≥n breve y consecuencias positivas o negativas dependiendo de la situaci√≥n (en contexto futbol).",
        "acciones_recomendadas": "Sugerencias para mejorar el estado emocional/rendimiento o c√≥mo mantenerlo."
      }

      Responde solo con el JSON, sin texto adicional.`;

      const response = await genAI.getGenerativeModel({ model: 'gemini-2.0-flash' }).generateContent(prompt);
      let rawText = response.response.text();

      rawText = rawText.replace(/```json/g, '').replace(/```/g, '').trim();
      return JSON.parse(rawText);
    } catch (error) {
      console.error('Error al generar an√°lisis con Gemini:', error);
      throw new Error(ERROR_MESSAGES.NLP_ANALYSIS_FAILED);
    }
  }

  static async translateToEnglishWithGemini(text: string): Promise<string> {
    try {
      const prompt = `Traduce el siguiente texto del espa√±ol al ingl√©s. Responde solo con la traducci√≥n, sin explicaciones:\n"${text}"`;

      const response = await genAI
        .getGenerativeModel({ model: 'gemini-2.0-pro' }) // o el modelo que est√©s usando
        .generateContent(prompt);

      const translatedText = response.response.text().trim();
      console.log("üîÑ Traducci√≥n (Gemini):", translatedText);
      return translatedText;
    } catch (error) {
      console.error("‚ùå Error al traducir con Gemini:", error);
      throw new Error("Error al traducir el texto al ingl√©s.");
    }
  }

  static async translateEmotionToSpanishWithGemini(emotion: string): Promise<string> {
    try {
      const prompt = `Traduce al espa√±ol solo esta palabra de emoci√≥n: "${emotion}". Responde √∫nicamente con la traducci√≥n.`;

      const response = await genAI
        .getGenerativeModel({ model: 'gemini-2.0-pro' })
        .generateContent(prompt);

      const translatedEmotion = response.response.text().trim().toLowerCase();

      console.log("üåê Emoci√≥n traducida:", translatedEmotion);
      return translatedEmotion;
    } catch (error) {
      console.error("‚ùå Error traduciendo emoci√≥n con Gemini:", error);
      throw new Error("Error al traducir la emoci√≥n al espa√±ol.");
    }
  }

}
